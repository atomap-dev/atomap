.. _finding_atom_lattices:

************************
Finding the atom lattice
************************

The first step in using Atomap to analyse atomic resolution STEM images is to find the position of the atomic columns in the image.
This tutorial will show how to do this from scratch:

1. Finding the feature separation
2. Generate initial positions for the atomic columns and initialize a *Sublattice*
3. Refine the position of the atomic columns
4. Construct the zone axes

In this tutorial, the datasets from which the atomic positions are found are generated by using functionality in Atomap that generates test datasets.
We will use an image of a simple cubic structure to introduce the basic steps.

After and fitting a 2D-Gaussian each atomic column a variety of structural information, such as the distance between atoms and monolayers, and ellipticity can be extracted.
This will be dealt with in the tutorial :ref:`analysing_atom_lattices`.

If want to analyse many images of the same atomic structure, the process can be made more automatic by using process parameters.
Process parameters are treated in :ref:`automatation`.

A simple cubic structure
========================

The dataset used in this example is will be generated by using functionality for generating test images in *atomap.dummy_data*.

.. code-block:: python

    >>> import atomap.api as am
    >>> import numpy as np
    >>> import atomap.dummy_data as dummy_data

    >>> s = dummy_data.get_simple_cubic_signal(image_noise=True)
    >>> s.plot() # doctest: +SKIP

.. image:: images/finding_atom_lattices/sc_image.png
    :scale: 50 %
    :align: center

White noise was added to the image, in order to make it more realistic.
To use your own images rather than this test dataset, load your own image for example by using HyperSpy.
HyperSpy supports for example dm3-files.

.. code-block:: python

    >>> import hyperspy.api as hs # doctest: +SKIP
    >>> your_image = hs.load(your_filename) # doctest: +SKIP
    
We will continue with the test dataset *s*.

1. Finding the feature separation
---------------------------------

Atomap finds initial positions for the atomic columns by using a peak finding algorithm from the python package skimage.
This algorithm needs to know the smallest peak separation (minimum pixel separation of the features).
You can find the optimal pixel separation by using the Atomap function *get_feature_separation()* which returns a HyperSpy signal.

.. code-block:: python

    >>> s_peaks = am.get_feature_separation(s,separation_range=(2, 20))

This function tests the peak finding algorithm for a range of pixel separations.
The default separation range is 5 to 30.
*s_peaks* is plotted below.
The left figure shows where the peak finding function has located a peak, the right figure shows the minimum feature separation in pixels on the x-axis.
Use the left-right arrow keys to navigate through the different minimum feature separation, and see how it affects the result of the peak finding in the left figure.

.. code-block:: python

    >>> s_peaks.plot()

.. image:: images/finding_atom_lattices/peak_finding_1.png
    :align: center


The requirements for the peak separation are:

1.  With an optimal peak separation, only atoms from one sublattice should be marked.
2.  In addition, all the atoms from the first sublattice should be marked.
    (It is not necessary that all the atoms at the edges are marked).

With a pixel separation of 2, too many atoms are found. 

.. image:: images/finding_atom_lattices/peak_finding_2.png
    :align: center

With a pixel separation of 7, all atoms are identified.
Often, the program will have difficulties with finding the atoms in the rows at the boundary of the image.
This does not matter, the important thing is that all atoms in the middle of the image are found.

.. image:: images/finding_atom_lattices/peak_finding_3.png
    :align: center

12 is a too large pixel separation, not all atoms in the "centre" of the image are found.

2. Generate the initial positions for the atomic columns and initialize a *Sublattice*
--------------------------------------------------------------------------------------

Having found the optimal feature separation, it is time to generate the initial atomic positions.
*get_atom_positions* takes the atomic resolution image signal *s* and the optimal feature separation.
The function also allows for pca, background subtraction and normalization of intensity, these options are described in
`the api documentation <http://atomap.org/api_documentation.html#atomap.atom_finding_refining.get_atom_positions>`_.

.. code-block:: python

    >>> atom_positions = am.get_atom_positions(s,separation=7)

*atom_positions* is a list of x and y coordinates for initial atom positions.
This list will be used to initialize a *Sublattice* object, which will contain all the information about the atoms.
In our simple example, all atoms belong to the same sublattice, and only one *Sublattice* is needed.
(In the more advanced example below, images containing more than one sublattice will be analysed).
The *Sublattice* object takes a list of atom positions, and a 2D numpy array representing the image.

.. code-block:: python

    >>> sublattice = am.Sublattice(atom_positions,image=s.data)
    >>> sublattice
    <Sublattice,  (atoms:400,planes:0)>

3. Refine the position of the atomic columns
--------------------------------------------

Atomap uses `centre of mass <http://atomap.org/api_documentation.html#atomap.atom_position.Atom_Position.refine_position_using_center_of_mass>`_ first,
and then a `2D-Gaussian <http://atomap.org/api_documentation.html#atomap.atom_position.Atom_Position.refine_position_using_2d_gaussian>`_ to refine the position (and shape) of an atomic column.
Before the refinement, the nearest neighbours of each atomic column must be found.
This is needed to for Atomap to know boundary values for the position refinement.

.. code-block:: python

    >>> sublattice.find_nearest_neighbors()
    >>> sublattice.refine_atom_positions_using_center_of_mass()
    >>> sublattice.refine_atom_positions_using_2d_gaussian()

Let's see what how the refinement procedure have improved the atom positions.

.. code-block:: python

    >>> sublattice.get_position_history().plot() # doctest: +SKIP

Again, navigate through from the initial positions, to the positions after the first and second refinement, in this case the centre of mass and 2D-Gaussian respectively.
Below, the initial and end position are shown.

.. image:: images/finding_atom_lattices/pos_hist_1.png
    :align: center

.. image:: images/finding_atom_lattices/pos_hist_2.png
    :align: center

Atom positions have clearly been improved by the refinement.
The quality of the fit is seen more clearly when we zoom in on the atoms.

.. image:: images/finding_atom_lattices/pos_hist_2_zoom.png
    :align: center

Information on the atoms in a sublattice can always be accessed, as *Sublattice* holds a list of all atom columns (atom positions).
All atoms are in *atom_list*. 

.. code-block:: python

    >>> atom_list = sublattice.atom_list
    >>> atom_list[0] # doctest: +SKIP
    <Atom_Position,  (x:290.2,y:289.9,sx:3.1,sy:3.2,r:0.2,e:1.0)> # doctest: +SKIP

*Sublattice* also holds lists of all the atom position coordinates, ellipticity, the sigma of the Gaussian, etc....

4. Construct zone axes
----------------------

Explain why this is done, and that it is best to do it after 3.
Also explain the effect of missing atoms on this (ref part 1)

.. code-block:: python
    
    >>> sublattice.construct_zone_axes()
    >>> sublattice # doctest: +SKIP
    <Sublattice,  (atoms:400,planes:4)> # doctest: +SKIP

*construct_zone_axes* does what the function name implies.
The zone axes are needed for the types of analysis explained in :ref:`analysing_atom_lattices`.
Show zone axes and atom planes (atom numbers).

Images with more than one sublattice
====================================

Often, the imaged crystal structure will have more than one sublattice.
We will now find the atom positions in an image containing two sublattices, where the atomic columns in one of the sublattices are more intense than in the other.
Again, we use a dummy dataset generated using *atomap.dummy_data*. 

.. code-block:: python

    >>> s = dummy_data.get_two_sublattice_signal()
    >>> s_peaks = am.get_feature_separation(s)
    >>> A_positions = am.get_atom_positions(s,separation=14)
    >>> sublattice_A = am.Sublattice(A_positions,image=s.data)
    >>> sublattice_A.find_nearest_neighbors()
    >>> sublattice_A.refine_atom_positions_using_center_of_mass()
    >>> sublattice_A.refine_atom_positions_using_2d_gaussian()
    >>> sublattice_A.construct_zone_axes()
    >>> sublattice_A.get_all_atom_planes_by_zone_vector().plot()
    
    
    
